//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// Mikael Fridenfalk
// Artificial Intelligence for Game Programming 1, 7.5 c
// Uppsala University, Sweden
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
#include "MidiGen.h"
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
MidiGen::MidiGen(void){
	mTrack = new UCHAR [TRACK_BUFFER_SIZE];
	mPPQN = 480; // Pulses Per Quarter Note; 1 bar = 4 beats = 4*mPPQN
	mFileName = (char*)"MyMidiFile.mid";
	mTempo = 120.f;// Tempo (beats per minute)
    mChannel = 0;
}
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
MidiGen::~MidiGen(void){
	delete [] mTrack;
}
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
//                                 Core
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
void MidiGen::GenerateMidi(){
	// Midi notes are generated by turning notes on and off.
	// In this template, a note is turned on by a velocity value
	// of 1 to 127 and turned off by a velocity value of 0.
	// 
	// The time pointer is moved forward by insertion of "variable length
	// data": InsertVarLengthData(x) is used moving the time arrow by x
	// pulses. A quarter note is mPPQN pulses long, or in this example,
	// 480 pulses (a common value for mPPQN).
	// A pulse is a measure of the smallest time unit in our system
	// (similar to the concept of grid points).
	//
	// Exactly what a pulse corresponds to in actual time (measured in
	// seconds), is determined by the tempo.
	// As an example, if the tempo is 120 beats per minute (bpm) and
	// mPPQN = 480, then each pulse is approximately equal to:
	// deltaTimeInSeconds = 60/(tempo*mPPQN) = 0.0010417 s <=> 1.0417 ms
	// So while deltaTimeInSeconds is in this example measured in
	// seconds, deltaTime is measured in pulses.
	//
	// Below follows an example of how to generate individual notes vs
	// simultaneous ones (chords).
	
	mN = 0;
	// Silence during 1/8 of a beat (audio fade in to match most
	// MIDI-players). Remove this line if you intend to import the
    // generated MIDI-file from a Digital Audio Workstation (DAW).
	InsertNote(mPPQN/8, 60, 0);

	// *** Start of music
	// Generate a couple of quarter notes (C3 and G3) to be played after
	// one another, each 1/4 (one beat) long:
    InsertNote(0,     60, 100);
    InsertNote(mPPQN, 60, 0);
    InsertNote(0,     67, 100);
    InsertNote(mPPQN, 67, 0);
    
    // Play an octave (C3 and C4 simultaneously)
    InsertNote(0,     60, 100);
    InsertNote(0,     72, 100);
    InsertNote(mPPQN, 60, 0);
    InsertNote(0,     72, 0);
	// *** End of music
    
    // In InsertNote(deltaTime, pitch, vel), velocity (vel) denotes the
	// volume of the note (1-127), here set to 100.

	// Silence during a beat (audio fade out)
	InsertNote(mPPQN, 60, 0);
}
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
void MidiGen::InsertVarLengthData(UINT value){//Insert Variable Length Data
	UINT buffer; buffer = value & 0x7F;
	while ( (value >>= 7) ){ buffer <<= 8; buffer |= ((value & 0x7F) | 0x80);}
	while (true){
		mTrack[mN++] = buffer;
    if (buffer & 0x80) buffer >>= 8; else break;}
}
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------










//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
//   (c) Mikael Fridenfalk
//   The code below is written to be used in course:
//   Artificial Intelligence for Game Programming 1, 7.5 c
//   Uppsala University, Sweden
//   The code can be regarded as a black box...
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
void MidiGen::InsertNote(UINT deltaTime, UCHAR pitch, UCHAR vel){
	InsertVarLengthData(deltaTime);
	mTrack[mN++] = UCHAR (0x80 + (vel > 0)*0x10 + mChannel);
	mTrack[mN++] = pitch; //Pitch
	mTrack[mN++] = vel; //Velocity
}
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
void MidiGen::Insert_MicroTempo(int microTempo){
	//FF 51 03 tt tt tt (microTempo unit: microseconds per quarter note)
	mTrack[mN++] = 0xFF;
	mTrack[mN++] = 0x51;
	mTrack[mN++] = 0x03;
	mTrack[mN++] = microTempo >> 16 & 0xFF;
	mTrack[mN++] = microTempo >> 8 & 0xFF;
	mTrack[mN++] = microTempo & 0xFF;
}
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
void MidiGen::Insert_TimeSignature(UCHAR num, UCHAR den){//FF 58 04
	mTrack[mN++] = 0xFF;
	mTrack[mN++] = 0x58;
	mTrack[mN++] = 0x04;
	mTrack[mN++] = num; // num/den
	mTrack[mN++] = den; // denominator = 2^(-den)
	mTrack[mN++] = 0x18;
	mTrack[mN++] = 0x08;
}
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
USHORT MidiGen::FlipEndian(USHORT x){return x << 8 | x >> 8;}//MSB|LSB
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
UINT MidiGen::FlipEndian(UINT x){//MSB| | |LSB
    return x << 24 | (x & 0xFF00) << 8 | (x >> 8 & 0xFF00) | x >> 24;
}
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
//                                 FILE
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
void MidiGen::F_ExportMidi(){
    mOutFile.open (mFileName);
    if (!mOutFile.is_open()){cout << "File Open Error\n"; return;}
	F_WriteFileHeader(2);//Number of tracks = 2
	mN = 0;//------------------Track 1 (Tempo Track)
	int microTempo = int (500000.0f/mTempo*120.0f);
	InsertVarLengthData(0);
    Insert_MicroTempo(microTempo);
	InsertVarLengthData(0);
    Insert_TimeSignature(4,2);// 4/4 
	InsertVarLengthData(0);
    F_WriteTrack();
	mN = 0;//------------------Track 2 (Note Track)
	GenerateMidi();
	InsertVarLengthData(0);
    F_WriteTrack();
    mOutFile.close();
}
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
void MidiGen::F_WriteFileHeader(USHORT numTracks){
    mOutFile.write("MThd",4);
	UCHAR length[] = {0,0,0,6};
    mOutFile.write((const char*)length,4);
	UCHAR format[] = {0,1};
    mOutFile.write((const char*)format,2);
	numTracks = FlipEndian(numTracks);
    mOutFile.write((const char*)&numTracks,2);
	USHORT division = FlipEndian(mPPQN);
    mOutFile.write((const char*)&division,2);    
}
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
void MidiGen::F_WriteTrack(){
    mOutFile.write("MTrk",4);        
	UINT length = FlipEndian((UINT)mN+3);
    mOutFile.write((const char*)&length,4);
    mOutFile.write((const char*)mTrack,mN);
	const UCHAR END_OF_TRACK[] = {0xFF,0x2F,0x00};
    mOutFile.write((const char*)END_OF_TRACK,3);
}
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
