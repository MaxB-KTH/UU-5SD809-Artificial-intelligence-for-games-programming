//---------------------------------------------------------------------
//---------------------------------------------------------------------
//---------------------------------------------------------------------
//  Class Template - Assignment 1.2
//  Artificial Intelligence for Game Programming I - 5SD809
//  Uppsala University
//---------------------------------------------------------------------
//---------------------------------------------------------------------
//---------------------------------------------------------------------
#include "Game.h"
//---------------------------------------------------------------------
//---------------------------------------------------------------------
Game::Game(){
    mFrontBufferIdx = 1;
    mM = new bool[2][GRID_SIZE_Y][GRID_SIZE_X];
    ResetBuffers();
    //Add_Glider(10,10);
    //Add_LightweightSpaceship(5,5);
    Add_GosperGliderGun(5,5);
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
Game::~Game(){delete [] mM;}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
void Game::Add_Glider(int i, int j){
    char A[][4] = {
        "***",
        "  *",
        " * ",
    };
    For (ii,3) For (jj,3) mM[0][i+ii][j+jj] = A[ii][jj] == '*';
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
void Game::Add_LightweightSpaceship(int i, int j){
    char A[][6] = {
        " ****",
        "*   *",
        "    *",
        "*  * ",
    };
    For (ii,4) For (jj,5) mM[0][i+ii][j+jj] = A[ii][jj] == '*';
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
void Game::Add_GosperGliderGun(int i, int j){
    char A[][39] = {
        "                       **         **  ",
        "                      * *         **  ",
        "**       **           **              ",
        "**      * *                           ",
        "        **      **                    ",
        "                * *                   ",
        "                *                     ",
        "                                   ** ",
        "                                   * *",
        "                                   *  ",
        "                                      ",
        "                                      ",
        "                        ***           ",
        "                        *             ",
        "                         *            ",
    };
    For (ii,15) For (jj,38) mM[0][i+ii][j+jj] = A[ii][jj] == '*';
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
void Game::ResetBuffers(){
    For (k,2) For (i,GRID_SIZE_Y) For (j,GRID_SIZE_X){
        mM[k][i][j] = false;}
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
void Game::PrintGrid(int isFrontCurrent){
#ifdef _WIN32 //32-bit and 64-bit Windows
    system("cls");
#else //Typically Unix such as Mac OSX or Linux
    printf("\n\n\n\n\n");
#endif
    For (i,GRID_SIZE_Y){
        For (j,GRID_SIZE_X){
            if (mM[isFrontCurrent][i][j]){
                if (isFrontCurrent) printf(" *");
                else printf(" *");
            }
            else printf("  ");
        }
        printf("\n");
    }
    printf("\n");
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
void Game::Run(){
    PrintGrid(mFrontBufferIdx);
    For (i,500){
        //A relatively platform independent sleep function intead of
        //Sleep(t) in Windows and usleep(t*1000) in Unix
        std::this_thread::sleep_for(std::chrono::milliseconds(100));        
        UpdateFrontBuffer();
        mFrontBufferIdx = 1 - mFrontBufferIdx;
        PrintGrid(mFrontBufferIdx);
    }
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------



//---------------------------------------------------------------------
//---------------------------------------------------------------------
void Game::UpdateFrontBuffer(){
    //For each cell i and j, with
    //i = 0 ... I-1 and j = 0 ... J-1,
    //evaluate mM[mFrontBufferIdx][i][j] based on previous grid
    //mM[1-mFrontBufferIdx][i][j]
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
